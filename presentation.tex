\documentclass{beamer}
\usepackage[latin1]{inputenc}
\usepackage{tabularx}
\usepackage{tabulary}
\usetheme{Warsaw}
\title[Introducion to DBus]{Introducion to DBus}
\author{Daniel Kowalski}
\date{}

\defbeamertemplate*{footline}{shadow theme}{%
\leavevmode%
\hbox{\begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex,leftskip=.3cm plus1fil,rightskip=.3cm]{author in head/foot}%
    \usebeamerfont{author in head/foot}\hfill\insertshortauthor
\end{beamercolorbox}%

\begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex,leftskip=.3cm,rightskip=.3cm plus1fil]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle\hfill%
\insertframenumber\,/\,\inserttotalframenumber
\end{beamercolorbox}}%
\vskip0pt%
}


\begin{document}

\begin{frame}
\titlepage
\end{frame}

\AtBeginSection[]
{
   \begin{frame}
        \tableofcontents[currentsection,currentsubsection]
   \end{frame}
}

\begin{frame}{Some info}
  \begin{block}{sources}
    \url{https://github.com/daniel-kowalski/dbus-training.git}
  \end{block}
  \vfill
  \begin{block}{license}
    TBD - probably/for now: WTFPL v2
  \end{block}
  \vfill
  \begin{block}{version}
    @@@@@VERSION@@@@@
  \end{block}
\end{frame}

\begin{frame}
  \tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}{What is dbus}
  \begin{itemize}
    \item IPC (Inter-Process Communication) and RPC (Remote Procedure Calling) system
    \item messages based
    \item high level
    \item centralized (bus) - one central "messages router"
    \item language independent
    \item service-client architecture
  \end{itemize}
\end{frame}

\begin{frame}{Bibliography}
  \begin{exampleblock}{some useful links}
    \begin{small}
      \url{https://www.freedesktop.org/wiki/Software/dbus}\\
      \url{https://www.freedesktop.org/wiki/IntroductionToDBus}\\
      \url{https://pythonhosted.org/txdbus/dbus\_overview.html}\\
      \url{https://dbus.freedesktop.org/doc/dbus-faq.html}\\
      \url{https://dbus.freedesktop.org/doc/dbus-specification.html}\\
    \end{small}  
  \end{exampleblock}
\end{frame}

\begin{frame}{Where it is used}
  \begin{itemize}
    \item udev
    \item HAL (Hardware abstraction layer)
    \item Skype
    \item Pidgin
    \item VLC
    \item CUPS
  \end{itemize}
  \vfill
  \begin{exampleblock}{more examples}
    \begin{small}
      \url{https://www.freedesktop.org/wiki/Software/DbusProjects}
    \end{small}
  \end{exampleblock}
\end{frame}

\begin{frame}{DBus bus types}
Most of Linux distributions use two dbus bus instances (call also "types"):
  \begin{itemize}
    \item SYSTEM\_BUS - only one for whole system
    \item SESSION\_BUS - one for each user session
  \end{itemize}
  And there is no problem with spawning custom bus :).
\end{frame}

\section{Architecture}

\begin{frame}{Bus and some clients}
Names (sometimes called addresses):
  \begin{itemize}
    \item unique-id - mandatory for all clients, given by bus while connections established
    \item well-known-name - mandatory only for processes which wants to export objects (services), requested by clients
  \end{itemize}
  \begin{center}
    \includegraphics[scale=0.4]{bus_clients.png}
  \end{center}
\end{frame}

\begin{frame}{Sevice internal structure (1)}
  \begin{center}
    \includegraphics[scale=0.4]{service_full.png}
  \end{center}
\end{frame}

\begin{frame}{Sevice internal structure (2)}
\begin{huge}
- name 
\begin{normalsize}
-unique id and well-known-name\\
\end{normalsize}
\hspace{1cm}- object (path)\\
\hspace{2cm}- interface\\
\hspace{3cm}- method\\
\hspace{3cm}- signal\\
\hspace{3cm}- property\\
\end{huge}
\end{frame}

\begin{frame}{Members types}
  \begin{itemize}
    \item method - is a function called by client on the service side
    \item signal - is information emitted by service to clients (client will not get signal until it register for it)
    \item property - is data field of service (read/write)
  \end{itemize}
\end{frame}

\begin{frame}{Sevice internal structure (3)}
  \begin{center}
    \begin{tiny}
      \begin{tabulary}{1.0\textwidth}{|L|L|L|L|}
\hline
A... & is identified by a(n)... & which looks like... & and is chosen by...\\
\hline
\hline
bus & address & unix:path= /var/run/dbus/system\_bus\_socket & system configuration\\
\hline
connection & bus name & :1.34 (unique) or com.example.Audio (well-known) & D-Bus (unique) or the owning program (well-known)\\
\hline
object & path & /com/example/Audio & the owning program\\
\hline
interface & interface name & com.example.Audio.Master & the owning program\\
\hline
member & member name & AddPlayer & the owning program\\
\hline
      \end{tabulary}
    \end{tiny}
  \end{center}
\end{frame}

\begin{frame}{From system POV (1)}
  \begin{block}{}
    dbus-daemon - process representin dbus bus
  \end{block}
  \begin{center}
    \includegraphics[scale=0.35]{daemon_with_clients.png}
  \end{center}
  \url{https://dbus.freedesktop.org/doc/diagram.png}
\end{frame}

\begin{frame}{From system POV (2)}
  \begin{block}{A little conclusion...}
    \begin{large}
      DBus is introducing all these fancy abstraction like names, objects, interfaces, methods, etc, which are very helpful for developers (probably all dbus bindings are using them), but it is all sending and receiving messages (data packets) "under the hood".
    \end{large}
  \end{block}
\end{frame}

\begin{frame}{DBus types (1)}
  \begin{center}
    \begin{normalsize}
      \begin{tabulary}{1.0\textwidth}{|C|L|}
\hline
Character & Code Data Type\\
\hline
\hline
y & 8-bit unsigned integer\\
\hline
b & boolean value\\
\hline
n & 16-bit signed integer\\
\hline
q & 16-bit unsigned integer\\
\hline
i & 32-bit signed integer\\
\hline
u & 32-bit unsigned integer\\
\hline
x & 64-bit signed integer\\
\hline\
t & 64-bit unsigned integer\\
\hline
d & double-precision floating point (IEEE 754)\\
\hline
s & UTF-8 string (no embedded nul characters)\\
\hline
      \end{tabulary}
    \end{normalsize}
  \end{center}
\end{frame}

\begin{frame}{DBus types (2)}
  \begin{center}
    \begin{normalsize}
      \begin{tabulary}{1.0\textwidth}{|C|L|}
\hline
Character & Code Data Type\\
\hline
\hline
o & D-Bus Object Path string\\
\hline
g & D-Bus Signature string\\
\hline
a & Array\\
\hline
() & Structure\\
\hline
v & Variant type\\
\hline
\{\} & Dictionary/Map\\
\hline
h &Unix file descriptor\\
\hline
      \end{tabulary}
    \end{normalsize}
  \end{center}
\end{frame}

\begin{frame}{Signatures}
  \begin{itemize}
    \item as - array of strins
    \item ii - two integers 32bit
    \item (isb) - stucture of integer, string and bool
    \item a(si) - array of structs with string and int
    \item a\{is\} - dictionary/map: int to string
    \item a\{i(is)\} - map int to struct of int and string
  \end{itemize}
  \vfill
  \pause
  \begin{exampleblock}{And some exercises :)}
    \begin{itemize}
      \item ah
      \item ((ib)(is))
      \item a\{ia\{si\}\}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}{Methods vs Signals}
\begin{tabulary}{1.0\textwidth}{|C|C|}
\hline
method & signal\\
\hline
\hline
client is calling method on specific service side & service is "broadcasting" signal to unknown clients\\
\hline
1-to-1 communication & 1-to-many communication\\
\hline
reply can be send & no possibility of replying\\
\hline
\end{tabulary}
\vfill
\pause
It will be waste of resources if dbus-daemon will propagate each signal to each client. If client want to get signal message, it needs to register for it with right "matching rule". If all components of the matching rule match message, it will be transported to client.
\end{frame}

\begin{frame}{Matching rules (1)}
  \begin{small}
    \begin{center}
      \begin{tabulary}{1.0\textwidth}{|C|L|}
\hline
Key & Possible values\\
\hline
\hline
type & 'signal', 'method\_call', 'method\_return', 'error'\\
\hline
sender & a well-known or unique name\\
\hline
interface & an interface name\\
\hline
member & 	any valid method or signal name\\
\hline
destination & a well-known or unique name\\
\hline
arg[0, 1, 2, 3, ...] & Any string (match against arguments of message, but only strings)\\
\hline
eavesdrop & 'true', 'false' (from BDus 1.5.6 match rule will match message with set 'destination' field only if eavesdrop='true')\\
\hline
      \end{tabulary}
    \end{center}
  \end{small} 
\end{frame}

\begin{frame}{Matching rules (2)}
  \begin{block}{Wildcards}
    Omitting a key from the rule indicates a wildcard match
  \end{block}
  \vfill
  \pause
  \begin{itemize}
    \item "type='signal',sender='com.example.audio'"
    \item "type='method\_return',destination=':1.34'"
    \item "type='method\_call','com.example.audio'"
    \item "arg0='qwerty'" - only string aruments can be match against!
  \end{itemize}
  \vfill
  \begin{small}
    \begin{exampleblock}{for all keys and more extensive info visit}  
       \url{https://dbus.freedesktop.org/doc/dbus-specification.html} section 'Match Rules'\\
    \end{exampleblock}
  \end{small}
\end{frame}

\begin{frame}{Activation}
dbus-daemon can start service process on demand (explicit or when first message to service will be send) when it is configured to do it. Service file need to have extension '.service' and be placed in service directory of specific bus (for SESSION\_BUS eg: '/usr/share/dbus-1/services' - system depending).
\vfill
  \begin{block}{example.service}
  [D-BUS Service]\\
  Name=com.example.Audio;com.some.other.name\\
  Exec=/usr/bin/audio\\
  \end{block}
\end{frame}

\begin{frame}{Standard interfaces (1)}
  \begin{itemize}
    \item org.freedesktop.DBus.Introspectable
    \begin{itemize}
      \item Introspect(out STRING xml\_data)
    \end{itemize}
    \item org.freedesktop.DBus.Properties
    \begin{itemize}
      \item Get(in STRING interface\_name, in STRING property\_name, out VARIANT value)
      \item Set(in STRING interface\_name, in STRING property\_name, in VARIANT value)
      \item GetAll(in STRING interface\_name, out DICT[STRING,VARIANT] props)
      \item PropertiesChanged(STRING interface\_name, DICT[STRING,VARIANT] changed\_properties, ARRAY[STRING] invalidated\_properties) - signal
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Standard interfaces (2)}
  \begin{itemize}
  \item org.freedesktop.DBus.Peer
    \begin{itemize}
      \item Ping ()
      \item GetMachineId(out STRING machine\_uuid)
    \end{itemize}
  \item org.freedesktop.DBus.ObjectManager    
    \begin{itemize}
      \item GetManagedObjects(out DICT[OBJPATH,DICT[STRING,DICT[STRING,VARIANT]]] objpath\_interfaces\_and\_properties)
      \item InterfacesAdded(OBJPATH object\_path, DICT[STRING,DICT[STRING,VARIANT]] interfaces\_and\_properties) - signal
      \item InterfacesRemoved(OBJPATH object\_path, ARRAY[STRING] interfaces) - signal                                                
    \end{itemize}    
  \end{itemize}
\end{frame}

\begin{frame}{Bus service - org.fredesktop.DBus}
  \begin{block}{org.freedesktop.DBus}
  There is one special service on bus - org.freedesktop.DBus.\\
  It is exposed by dbus-daemon itself.\\Can be used for:\\
  \begin{itemize}
    \item managing connections - communication with it is necessary for process to which want to use bus (usually hidden from developer by library/bidding)
    \item getting information about bus state - eg. list of names, starting services, etc.
    \item etc.
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{org.freedesktop.DBus - members (1)}
  \begin{itemize}
\item Hello(out s arg\_0);
\item RequestName(in  s arg\_0,
            in  u arg\_1,
            out u arg\_2);
\item ReleaseName(in  s arg\_0,
            out u arg\_1);
\item StartServiceByName(in  s arg\_0,
                   in  u arg\_1,
                   out u arg\_2);
\item UpdateActivationEnvironment(in  a{ss} arg\_0);
\item NameHasOwner(in  s arg\_0,
             out b arg\_1);
\item ListNames(out as arg\_0);
\item ListActivatableNames(out as arg\_0);
\item AddMatch(in  s arg\_0);
\item RemoveMatch(in  s arg\_0);
\item GetNameOwner(in  s arg\_0,
             out s arg\_1);
\item ListQueuedOwners(in  s arg\_0,
  \end{itemize}
\end{frame}

\begin{frame}{org.freedesktop.DBus - members (2)}
  \begin{itemize}
\item GetConnectionUnixUser(in  s arg\_0,
                      out u arg\_1);
\item GetConnectionUnixProcessID(in  s arg\_0,
                           out u arg\_1);
\item GetAdtAuditSessionData(in  s arg\_0,
                       out ay arg\_1);
\item GetConnectionSELinuxSecurityContext(in  s arg\_0,
                                    out ay arg\_1);
\item GetConnectionAppArmorSecurityContext(in  s arg\_0,
                                     out s arg\_1);
\item ReloadConfig();
\item GetId(out s arg\_0);



\item NameOwnerChanged(s arg\_0,
                 s arg\_1,
                 s arg\_2);
\item NameLost(s arg\_0);
\item NameAcquired(s arg\_0);
  \end{itemize}
\end{frame}

\section{Using and debuging}

\begin{frame}{Basic tools}
  \begin{block}{dbus-send}
    sends method calls and prints reply
  \end{block}
  \begin{block}{dbus-monitor}
    eavesdrops method calls and signals
  \end{block}
  \begin{block}{gdbus}
    sends method calls and signals, introspects, monitors
  \end{block}
  \begin{block}{and not so basic - d-feet}
    gui tool which can be used as custom client (can not get signals)
  \end{block}
\end{frame}

\begin{frame}{dbus-send}
  \begin{itemize}
    \item dbus-send -{}-session -{}-print-reply -{}-type=method\_call -{}-dest=org.freedesktop.DBus / org.freedesktop.DBus.ListNames
    \item dbus-send -{}-session -{}-print-reply -{}-type=method\_call -{}-dest=org.freedesktop.DBus / org.freedesktop.DBus.GetConnectionUnixProcessID string:"org.gnome.ScreenSaver"
    \item dbus-send -{}-system -{}-print-reply -{}-type=method\_call -{}-dest=org.freedesktop.UDisks2 /org/freedesktop/UDisks2/block\_devices/sda org.freedesktop.DBus.Properties.Get string:"org.freedesktop.UDisks2.Block" string:"Id"
  \end{itemize}
\end{frame}

\begin{frame}{dbus-monitor}
  \begin{itemize}
    \item dbus-monitor
    \item dbus-monitor -{}-profile
    \item dbus-monitor -{}-session type="method\_call",destination="org.guake.RemoteControl"
    \item dbus-monitor -{}-session type="method\_call",destination="org.guake.RemoteControl",\\member='get\_selected\_tab' type="method\_return"
  \end{itemize}
\end{frame}

\begin{frame}{gdbus}
  \begin{itemize}
    \item gdbus introspect -{}-session -{}-dest org.guake.RemoteControl -{}-object-path /org/guake/RemoteControl
    \item gdbus monitor -{}-session -{}-dest org.freedesktop.DBus
    \item gdbus emit -{}-session -{}-object-path /ala/ma/kota -{}-signal ala.ma.kota.Mial "mial mial mial" 123
    \item gdbus call -{}-session -{}-dest org.freedesktop.Notifications -{}-object-path /org/freedesktop/Notifications -{}-method org.freedesktop.Notifications.Notify dummy-app 42 gtk-dialog-info  "Summary" "Body" [] \{\} 1000
  \end{itemize}
\end{frame}

\begin{frame}{Configuration}
  \begin{itemize}
    \item /etc/dbus-1
    \item /usr/share/dbus-1
    \item /etc/dbus-1/session.conf
    \item /etc/dbus-1/system.conf
    \item /usr/share/dbus-1/services/*.service
    \item /usr/share/dbus-1/system-services/*.service
    \item /usr/share/dbus-1/interfaces/*
  \end{itemize}
\end{frame}

\begin{frame}{Config file}
  \begin{itemize}
    \item type
    \item user
    \item fork
    \item listen
    \item limit
    \item policy
  \end{itemize}
  \hfill
  \begin{exampleblock}{full doc}
    \url{https://dbus.freedesktop.org/doc/dbus-daemon.1.html}
  \end{exampleblock}
\end{frame}

\begin{frame}{Polices}
  \begin{itemize}
    \item The 'policy' element defines a security policy to be applied to a particular set of connections to the bus. They are similar to firewall in that they are allowing expected traffic and denying unexpected.
    \item For now are normally used with SYSTEM\_BUS (block all by default) 
  \end{itemize}
  \vfill
  \begin{alertblock}{Be careful...}
    probably you will not get any information (timeout error instead of some specific one) if your action will be blocked by policy.
  \end{alertblock} 
\end{frame}

\begin{frame}
\begin{center}
\huge The end :)...
\end{center}
\end{frame}

\end{document}